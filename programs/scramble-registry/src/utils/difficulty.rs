/// Simple 256-bit unsigned integer comparison
///
/// Interprets two 32-byte arrays as little-endian 256-bit integers
/// and compares them.
///
/// Returns: true if `a < b`
pub fn u256_lt(a: &[u8; 32], b: &[u8; 32]) -> bool {
    // Compare from most significant byte (index 31) to least (index 0)
    for i in (0..32).rev() {
        if a[i] < b[i] {
            return true;
        } else if a[i] > b[i] {
            return false;
        }
    }
    // Equal
    false
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_u256_lt_simple() {
        // 0x42 < 0x80
        let a = [
            0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ];

        let b = [
            0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ];

        assert!(u256_lt(&a, &b));
        assert!(!u256_lt(&b, &a));
    }

    #[test]
    fn test_u256_lt_high_bytes() {
        // 0x0000...0001 vs 0x8000...0000 (high byte set)
        let a = [
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ];

        let b = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x80,
        ];

        // b is much larger (high bit set in most significant byte)
        assert!(u256_lt(&a, &b));
        assert!(!u256_lt(&b, &a));
    }

    #[test]
    fn test_u256_lt_equal() {
        let a = [0x42; 32];
        let b = [0x42; 32];

        assert!(!u256_lt(&a, &b)); // Equal, not <
        assert!(!u256_lt(&b, &a));
    }

    #[test]
    fn test_u256_lt_max() {
        // All 0xFF vs one less
        let max = [0xFF; 32];
        let mut almost_max = [0xFF; 32];
        almost_max[0] = 0xFE; // Least significant byte

        assert!(u256_lt(&almost_max, &max));
        assert!(!u256_lt(&max, &almost_max));
    }
}
