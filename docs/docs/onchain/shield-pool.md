---
title: Shield Pool Program
description: On-chain program that verifies SP1 withdraw proofs, manages roots and nullifiers, and executes private withdrawals.
---

# Shield Pool Program

The `shield-pool` program is written in Pinocchio (Rust) and deployed as a Solana BPF program. It verifies Groth16 proofs generated by the SP1 guest, enforces Merkle root membership, prevents double spends, and distributes lamports.

Source: [`programs/shield-pool`](https://github.com/cloak-labz/cloak/tree/main/programs/shield-pool)

## Account Model

- **Pool PDA (`pool`)** – Holds user deposits and collects fixed/variable fees.
- **Treasury PDA (`treasury`)** – Receives protocol fees during withdrawals.
- **Roots Ring (`roots_ring`)** – 64-slot ring buffer storing recent Merkle roots.
- **Nullifier Shard (`nullifier_shard`)** – Append-only set of used nullifiers (32-byte entries).
- **Recipients** – Writable accounts receiving lamports during withdraw.

## Instructions

| Tag | Instruction | Description |
| --- | --- | --- |
| `0x01` | `deposit` | Emits `deposit_commit:{hex}` log with commitment + encrypted output. Lamports are transferred via separate system instruction. |
| `0x02` | `admin_push_root` | Appends new Merkle root to ring buffer. Requires admin signer configured off-chain. |
| `0x03` | `withdraw` | Verifies SP1 proof, enforces invariants, transfers lamports, inserts nullifier. |

### Withdraw Data Layout

```
[tag: u8 = 0x03]
[groth16_proof: 260 bytes]
[sp1_public_inputs: 104 bytes]
[merkle_root: 32 bytes]
[nullifier: 32 bytes]
[amount: u64 LE]
[fee_bps: u16 LE]
[outputs_hash: 32 bytes]
[num_outputs: u8]
then each output: [recipient: 32 bytes] [amount: u64 LE]
```

The program recomputes the outputs hash internally using BLAKE3 on `(recipient, amount)` tuples.

## Proof Verification

- Uses `sp1-solana` crate to verify Groth16 proofs inside the program.
- Hardcodes the verification key hash produced by `packages/vkey-generator`.
- Accepts the 260-byte proof and 104-byte public inputs extracted by `packages/cloak-proof-extract`.

## Invariants

1. **Proof Validity:** `verify_proof()` must succeed.
2. **Root Containment:** `merkle_root` exists within the 64-slot ring buffer.
3. **Nullifier Uniqueness:** Provided `nf` must not be in the shard; program inserts it afterwards.
4. **Outputs Hash Integrity:** Recomputed hash matches the public input.
5. **Amount Conservation:** `sum(outputs) + protocol_fee == amount` (fee uses fixed + basis points policy).
6. **Account Validation:** Recipients match the outputs array order; PDAs are derived deterministically.

## Errors

| Code | Meaning |
| --- | --- |
| `0x1000` | Root not found in ring buffer. |
| `0x1001` | Groth16 proof verification failed. |
| `0x1002` | Nullifier already used. |
| `0x1003` | Outputs hash mismatch. |
| `0x1004` | Amount conservation violation. |
| `0x1005` | Arithmetic overflow during fee math. |
| `0x1006` | Bad account ordering/length. |
| `0x1007` | Invalid instruction payload length. |
| `0x1008` | Nullifier shard capacity exceeded. |
| `0x1009` | Unknown instruction tag. |

Errors appear in Solana logs and are surfaced by the relay when simulation fails.

## Testing

- `cargo test -p shield-pool` runs unit tests for instruction parsing, hashing, roots ring, and nullifier logic.
- Use `tooling/test` helpers to craft localnet transactions that exercise the full withdraw cycle.

## Deployment Checklist

1. Build with `cargo build-sbf --manifest-path programs/shield-pool/Cargo.toml`.
2. Deploy program using `solana program deploy` (store program ID for config/clients).
3. Initialise PDAs (pool, roots ring, nullifier shard) with the expected seeds.
4. Push at least one Merkle root from the indexer before processing withdrawals.
5. Keep the verification key hash in sync with the latest SP1 circuit release.

See the repository `README.md` and runbook for localnet deployment scripts.
